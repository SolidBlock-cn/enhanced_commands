# NBT 函数

**NBT 函数**（NBT function）用于对 NBT（包括 null 值）进行修改。

使用 [`/testarg nbt_function <NBT 函数> apply <NBT>`](../../commands/testarg/zh.md) 可对 NBT 函数进行测试并查看应用该 NBT 函数后的结果。

## 简单值

NBT 函数可以返回任意的 NBT 值，无论原来的 NBT 值是什么：

- `3b(2) = 3b`：对整数 `2` 应用 `3b` 函数，返回的值是 `3b`
- `4s("str") = 4s`：对字符串值 `"str"` 应用 `4s` 函数，返回的值是 `4s`
- `"str"({key: value}) = "str"`：对 NBT 复合标签应用 `"str"` 函数，返回的值是 `"str"`

> 可以用 `/testarg` 命令来测试 NBT 函数，例如运行 `/testarg nbt_function "str" apply {key: value}` 可以得到 `"str"`。
> 后面的这些例子都可以使用同样的方法来测试。

这也是最常见的 NBT 函数的类型。需要注意的是，上面的例子中的表达式仅用于示意，在模组中实际上并没有这样的语法。

## 等号值

等号值是指当原来的值是数字时，修改其数值但是保持其数据类型不变：

- `=3(2s) = 3s`：对短整型 `2s` 应用 `=3` 函数，取其数值 3 和原值的短整型类型，结果为短整型 `3s`
- `=3b(2) = 3`：对整型 `3` 应用 `=3b` 函数，取其值 3 和原值的整型类型，结果为整型 `3`

> 使用 `/testarg` 命令来测试 NBT 函数的例子：运行 `/testarg nbt_function =3b apply 2` 可以得到 `3`。

等号函数仅对数值有效，对于其他类型的值，则会直接替换值。

## 复合标签的合并

就像原版对 NBT 的合并操作一样，直接使用复合标签，会将复合标签合并：

- `{a: b, c: d}({a: "value", e: f}) = {a: b, c: d, e: f}`：a 字段被函数中的值替换，c 字段从函数中的值中加入，e 字段未在函数中定义因此未被影响

可以指定复合标签中的各个字段的值对原先的值如何计算：

- `{Color: 1b}({Color: 2}) = {Color: 1b}`：对复合标签的 `Color` 字段的值 `2` 应用 `1b` 函数
- `{Color = 1b}({Color: 2}) = {Color: 1}`：对复合标签的 `Color` 字段的值 `2` 应用 `=1b` 函数

复合标签或使用等号语法，则会替换整个复合标签，抛弃原复合标签中的所有值：

- `={a: b}({a: "value", c: d}) = {a: b}`：原复合标签的值（`{a: "value" ...}`）被完全抛弃，全部使用函数中的复合标签的值。
- `{tag = {a: b}}({tag: {c: d}})`：对复合标签中的 `tag` 字段应用等号函数，该字段的原先的值 `{c: d}` 被完全抛弃，全部使用 `{a: b}`。

使用 `- <键>` 以表示从该复合标签中移除，注意“`-`”和键之间必须要有空格，否则会连同连字符一起视为普通的键：

- `{- a}({a: b, c: d}) = {c: d}`：从该复合标签中移除了 `a`
- `{-a}`：无效的 NBT 函数
- `{-a: b}({a: b, c: d}) = {a: b, c: d, -a: b}`：`-a` 被视为常规的键

## 列表操作

默认情况下，列表会直接将原先的值完全抛弃，全部使用指定的值：

- `[a, b, c]([1]) = [a, b, c]`
- `[a, b, c]([4, 5, 6]) = [a, b, c]`
- `[a, b, c]([]) = [a, b, c]`
- `[]([a, b, c]) = []`

使用省略号可以为列表插值，表示在列表的前面或者后面插值。在一个列表 NBT 函数中，省略号只能出现一次：

- `[A, ...]([a, b, c]) = [A, a, b, c]`：在整个列表前插入字符串 `A`
- `[A, B, ...]([a, b, c]) = [A, B, a, b, c]`：在整个列表前插入字符串 `A` 和 `B`
- `[..., A]([a, b, c]) = [a, b, c, A]`：在整个列表后插入字符串 `A`
- `[A, ..., B]([a, b, c]) = [A, a, b, c, B]`：在整个鲭前插入字符串 `A`，在列表后插入字符串 `B`
- `[A, ..., B, ..., C]`：这个函数无效，因为省略号出现了两次，无法理解怎么插入值

可以在值前指定索引，表示替换特定位置的值，特定位置的值不存在时会被忽略：

- `[0: A]([a, b, c]) = [A, b, c]`：将列表的第 1 个值替换为 `A`
- `[1: A]([a, b, c]) = [a, A, c]`：将列表的第 2 个值替换为 `A`
- `[-1: A]([a, b, c]) = [a, b, A]`：将列表的最后一个值替换为 `A`
- `[3: A]([a, b, c]) = [a, b, c]`：列表没有第 4 个值，所以会被忽略

也可以在索引的位置插值，有两种方法，一种是添加省略号（插值语法在省略号前或后都是有效的），另一种是使用分号，且允许一次插值多个值：

- `[2: A, ...]([a, b, c]) = [a, b, A, c]`：在第 3 个元素的位置插入字符串 `A`
- `[..., 2: A]([a, b, c]) = [a, b, A, c]`：和前一个例子等价
- `[; 2: A]([a, b, c]) = [a, b, A, c]`：和前一个例子等价
- `[1: A, B, ...]([a, b, c]) = [a, A, B, b, c]`：在第 2 个元素的位置插入两个字符串 `A` 和 `B`
- `[-2: A, ...]([a, b, c]) = [a, b, A, c]`：在倒数第 2 个元素的位置插入字符串 `A`
- `[0: A; 2: B]([a, b, c]) = [A, b, B, c]`：将第 1 个元素的值替换为 `A`，并在第 3 个元素的位置插入值 `B`

> 在部分情况下，使用分号可能会使得列表被解析为数组，例如 `[2;... 3]` 可能被误解析为数组从而导致解析错误。在这种情况下，可以通过添加空格来规避此问题，因为数组的识别是对空格敏感的。

和列表元素替换一样，当插值的位置不存在时，会忽略这个插值。

列表的所有元素都必须是相同类型的，如果在处理过程中遇到类型错误，则无法正常修改列表。

应用列表函数时，若原先的值为 null 或非列表类型，则会将此值抛弃，并对空列表进行计算。

- `[A, ..., B]("string") = [A, B]`：原先的字符串值忽略，对空列表应用函数 `[A, ..., B]`